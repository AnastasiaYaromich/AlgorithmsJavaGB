Задание №1: Прочитать в книге "Грокаем алгоритмы" или в предложенных материалах про алгоритмы и О-большое.
Выполнено. Прочитано две главы.
___________________________________________________________
Задание №2: Определить сложность следующих алгоритмов:

2.1. Поиск элемента массива с известным индексом.
Ответ: O(1).
Обоснование:  Так как индекс искомого элемента нам известен вне заисимости от размера массива для достижения результата необходимо произвести овдну операцию.

2.2. Дублирование одномерного массива через foreach.
Ответ: O(n).
Обоснование:   В данном случае нужно перебрать все элементы массива, таким образом получается одна операция на каждый элемент. И чем больше будет массив, тем больше будет операций.

2.3. Удаление элемента массива с известным индексом без сдвига.
Ответ: O(1).
Обоснование:   Вне зависимости от размера массива для достижения результата необходимо произвести одну операцию: удалить элемент массива зная его индекс.
Т.к. удаление без сдвига смещать элементы массива не нужно, поэтому сложность здесь O(1).

2.4. Удаление элемента массива с неизвестным индексом без сдвига.
Ответ: O(n).
Обоснование:    В данном случае нужно перебрать элементы массива и в худшем случаем понадобится n операций, чтобы найти удаляемый элемент.  Однако, если массив упорядочен можно воспользоваться бинарным поиском O(logn). При большом количестве элементов бинарный поиск ГОРАЗДО быстрее линейного. Но так как здесь не указано упорядочен ли массив - ответ O(n).

2.5. Удаление элемента массива с неизвестным индексом со сдвигом.
Ответ: O(n).
Обоснование:    В данном случае также  нужно перебрать элементы массива и в худшем случаем понадобится n операций, чтобы найти и удалить нужный элемент.  Так как удаление со сдвигом понадобится еще один цикл for для сдвига элементов. --> O(n + n) = O(n).

____________________________________________________________________________
Задание №3: Определить сложность следующих алгоритмов. Сколько произойдет итераций?

a) int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < n; j *= 2) {
                arrayList.add(i * j);
            }
        }
Ответ: O(nlogn). Число итераций --> 140000.

b)  int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i += 2) {
            for (int j = i; j < n; j++) {
                arrayList.add(i * j);
            }
        }
Ответ: O(n^2). Число итераций -->  25000000.


c)    int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < n; j++) {
                arrayList.add(i * j);
                n--;
            }
        }
Ответ: O(n). Число итераций -->  9991. (Хотя здесь и вложенный цикл, число итераций прямо пропорционально количеству элементов).


d) factorial(BigInteger.valueOf(10000))
public static BigInteger factorial(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return n;
    }
    return n.multiply(factorial(n.subtract(BigInteger.valueOf(1))));
}
Ответ: O(n). Число итераций -->  10000.


e) fib(BigInteger.valueOf(50));
public static BigInteger fib(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return BigInteger.ZERO;
    }
    if (n.equals(BigInteger.TWO)) {
        return BigInteger.ONE;
    }
    return fib(n.subtract(BigInteger.ONE)).add(fib(n.subtract(BigInteger.TWO)));
}
Ответ: O(2^n). Число итераций --> 1.125*10^15.
____________________________________________________________________________
